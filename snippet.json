{
	"String Hashing": {
		"prefix": "strhsh",
		"body": [
		  "const int N = 100;",
		  "const int mod = 1e9 + 7;",
		  "const int base = 33;",
		  " ",
		  "int add(int a, int b, int mod){",
		  "    int res = (a + b) % mod;",
		  "    if(res < 0)",
		  "        res += mod;",
		  "    return res;",
		  "}",
		  " ",
		  "int mult(int a, int b, int mod){",
		  "    int res = (a * 1LL * b) % mod;",
		  "    if(res < 0)",
		  "        res += mod;",
		  "    return res;",
		  "}",
		  " ",
		  "int power(int a, int b, int mod){",
		  "    int res = 1;",
		  "    while(b){",
		  "        if((b % 2) == 1)",
		  "            res = mult(res, a, mod);",
		  "        a = mult(a, a, mod);",
		  "        b /= 2;",
		  "    }",
		  "    return res;",
		  "}",
		  " ",
		  "int pw[N];",
		  "int inv[N];",
		  "int H[N];",
		  " ",
		  "void precalc() {",
		  "    pw[0] = 1;",
		  "    for(int i = 1; i < N; i++)",
		  "        pw[i] = mult(pw[i - 1], base, mod);",
		  "    ",
		  "    int pw_inv = power(base , mod - 2 , mod);",
		  "    inv[0] = 1;",
		  "    for(int i = 1; i < N; i++)",
		  "        inv[i] = mult(inv[i - 1], pw_inv, mod);",
		  "}",
		  " ",
		  "void build(string s){",
		  "    int n = s.length();",
		  "    for(int i = 0; i < n ; ++i){",
		  "        H[i] = add((i == 0) ? 0 : H[i - 1], mult(pw[i], s[i] - 'a' + 1, mod), mod);",
		  "    }",
		  "}",
		  " ",
		  "int getHash(int x , int y){",
		  "    int res = add(H[y], (x == 0) ? 0 : -H[x - 1], mod);",
		  "    res = mult(res , (x == 0) ? 1 : inv[x], mod);",
		  "    return res;",
		  "}"
		],
		"description": "String Hashing"
	  },
	  "Default CPP": {
		"prefix": "def",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "",
		  "using namespace std;",
		  "using namespace __gnu_pbds;",
		  "",
		  "#define vi vector<int>",
		  "#define vll vector<ll>",
		  "#define vvi vector < vi >",
		  "#define vpii vector < pair <int,int> >",
		  "#define pb(x) push_back(x)",
		  "#define pii pair<int,int>",
		  "#define pll pair<long long, long long>",
		  "#define all(c) c.begin(),c.end()",
		  "#define mp(x,y) make_pair(x,y)",
		  "#define mem(a,val) memset(a,val,sizeof(a))",
		  "#define eb emplace_back",
		  "#define ff first",
		  "#define ss second",
		  "#define lc(p) (p << 1)",
		  "#define rc(p) (p << 1) | 1",
		  "#define ps(x, y) fixed << setprecision(y) << x",
		  "#define mk(arr, n, type) type *arr = new type[n]",
		  "#define range(a, b) substr(a, b - a + 1)",
		  "#define trace(x) cerr << #x << \": \" << x << endl",
		  "#define FIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)",
		  "#define input(arr,n) FOR(i,0,n) cin>>arr[i]",
		  "#define FOR(i,k,n) for ( int i=k; i<n; i++ )",
		  "#define ROF(i,k,n) for ( int i=k; i>n; i-- )",
		  "#define ll long long",
		  "#define casePrint(x,y) cout<<\"Case #\"<<x<<\": \"<<y;",
		  "#define each(x,a) for (auto &x : a)",
		  "",
		  "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
		  "",
		  "void fnc()",
		  "{",
		  "    ",
		  "}",
		  "",
		  "signed main(){",
		  "    FIO;",
		  "    int n;",
		  "    cin>>n;",
		  "    FOR(i,0,n)",
		  "    {",
		  "        fnc();",
		  "        cout<<\"\\n\";",
		  "    }",
		  "}"
		],
		"description": "Default CPP"
	  },
	  "Binary Search": {
		"prefix": "binsea",
		"body": [
		  "int BS(vi &a, int key)",
		  "{",
		  "    int l=0,r=a.size()-1;",
		  "    while(l<=r)",
		  "    {",
		  "        int mid=(l+r)/2;",
		  "        if (a[mid]==key)",
		  "            return mid;",
		  "        else if (a[mid]>key)",
		  "            r=mid-1;",
		  "        else",
		  "            l=mid+1;",
		  "    }",
		  "    return -1;",
		  "}"
		],
		"description": "Binary Search"
	  },
	  "String KMP": {
		"prefix": "kmp",
		"body": [
		  "int KMP(string s, string p)",
		  "{",
		  "    int lps[p.length()];",
		  "    lps[0]=0;",
		  "",
		  "    FOR(i,1,p.length())",
		  "    {",
		  "        int ci = lps[i-1];",
		  "",
		  "        while( ci>=1 && p[i]!=p[ci] )",
		  "            ci = lps[ci-1];",
		  "        ",
		  "        if ( p[i]!=p[ci] )",
		  "            lps[i]=ci;",
		  "        else",
		  "            lps[i] = ci+1;",
		  "    }",
		  "",
		  "    int ci=0;",
		  "    int ans=0;",
		  "",
		  "    FOR(i,0,s.length())",
		  "    {",
		  "        while( ci==p.length() || (ci>=1 && s[i]!=p[ci]) )",
		  "            ci = lps[ci-1];",
		  "        if ( s[i]==p[ci] )",
		  "            ci++;",
		  "        if (  ci==p.length())",
		  "            ans++;",
		  "    }",
		  "    return ans;",
		  "}",
		  ""
		],
		"description": "String KMP"
	  },
	  "DSU": {
		"prefix": "dsu",
		"body": [
			"#define max_size 100000",
			"int parent[max_size];",
			"int size_[max_size];",
			"",
			"int find_set(int v) {",
			"    if (v == parent[v])",
			"        return v;",
			"    return parent[v] = find_set(parent[v]);",
			"}",
			"",
			"void make_set(int v) {",
			"    parent[v] = v;",
			"    size_[v] = 1;",
			"}",
			"",
			"void union_sets(int a, int b) {",
			"    a = find_set(a);",
			"    b = find_set(b);",
			"    if (a != b) {",
			"        if (size_[a] < size_[b])",
			"            swap(a, b);",
			"        parent[b] = a;",
			"        size_[a] += size_[b];",
			"    }",
			"}"
		  ],
		"description": "DSU"
	  },
	  "Binary Lifting - LCA": {
		"prefix": "BLCA",
		"body": [
		  "int timer,l,size;",
		  "vector<int> tin, tout;",
		  "vector<vector<int>> up;",
		  "",
		  "void dfs(int v, int p)",
		  "{",
		  "    tin[v] = ++timer;",
		  "    up[v][0] = p;",
		  "    for (int i = 1; i <= l; ++i)",
		  "        up[v][i] = up[up[v][i-1]][i-1];",
		  "",
		  "    for (int u : adj[v]) {",
		  "        if (u != p)",
		  "            dfs(u, v);",
		  "    }",
		  "",
		  "    tout[v] = ++timer;",
		  "}",
		  "",
		  "bool is_ancestor(int u, int v)",
		  "{",
		  "    return tin[u] <= tin[v] && tout[u] >= tout[v];",
		  "}",
		  "",
		  "int lca(int u, int v)",
		  "{",
		  "    if (is_ancestor(u, v))",
		  "        return u;",
		  "    if (is_ancestor(v, u))",
		  "        return v;",
		  "    for (int i = l; i >= 0; --i) {",
		  "        if (!is_ancestor(up[u][i], v))",
		  "            u = up[u][i];",
		  "    }",
		  "    return up[u][0];",
		  "}",
		  "",
		  "void preprocess(int root) {",
		  "    tin.resize(size);",
		  "    tout.resize(size);",
		  "    timer = 0;",
		  "    l = ceil(log2(size));",
		  "    up.assign(size, vector<int>(l + 1));",
		  "    dfs(root, root);",
		  "}"
		],
		"description": "Binary Lifting - LCA"
	  },
	  "BIT - Fenwick Tree": {
		"prefix": "fwick",
		"body": [
		  "struct Bit{",
		  "    vi bit;",
		  "    int n;",
		  "",
		  "    Bit(int max_n) {",
		  "        n = max_n + 1;",
		  "        bit.assign(n, 0);",
		  "    }",
		  "",
		  "    Bit(vi a) : Bit(a.size()) {",
		  "        FOR(i,0,a.size())",
		  "            add(i+1, a[i]);",
		  "    }",
		  "",
		  "    int query(int idx) {",
		  "        int query = 0;",
		  "        while (idx > 0) {",
		  "            query += bit[idx];",
		  "            idx -= (idx & -idx);",
		  "        }",
		  "    return query;",
		  "    }",
		  "",
		  "    int query(int l, int r) {",
		  "        return query(r) - query(l - 1);",
		  "    }",
		  "",
		  "    void add(int idx, int val) {",
		  "        while (idx < n) {",
		  "            bit[idx] += val;",
		  "            idx += (idx & -idx);",
		  "        }",
		  "    }",
		  "",
		  "    void add(int l, int r, int val) {",
		  "        add(l, val);",
		  "        add(r + 1, -val);",
		  "    }",
		  "};"
		],
		"description": ""
	  },
	  "Graph bfs": {
		"prefix": "bfsg",
		"body": [
		  "const int N = 1e5 + 5;",
		  "",
		  "vi adj[N];",
		  "bool vis[N];",
		  "int d[N];",
		  "",
		  "void bfs(int src)",
		  "{",
		  "    int u;",
		  "    queue<int> Q;",
		  "    d[src] = 0;",
		  "    vis[src] = 1;",
		  "    Q.push(src);",
		  "    while(!Q.empty()) {",
		  "        u = Q.front(); ",
		  "        Q.pop();",
		  "        for(auto v : adj[u]) {",
		  "            if (vis[v] == 0) {",
		  "                d[v] = d[u] + 1;",
		  "                vis[v] = 1;",
		  "                Q.push(v);",
		  "            }",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "Graph bfs"
	  },
	  "Dijkstra": {
		"prefix": "djik",
		"body": [
		  "",
		  "const int N = 1e5 + 5;",
		  "",
		  "vpii adj[N];",
		  "bool vis[N];",
		  "int d[N];",
		  "",
		  "priority_queue<pii, vector<pii>, greater<pii>> PQ; ",
		  "",
		  "void djikstra(int src) {",
		  "",
		  "    int u,v,w;",
		  "    d[src] = 0;",
		  "",
		  "    PQ.push({0, src});",
		  "",
		  "    while(!PQ.empty()) {",
		  "        u = PQ.top().second;",
		  "        PQ.pop();",
		  "        if(vis[u])  continue;",
		  "        vis[u] = 1;",
		  "        for(auto &x : adj[u]) {",
		  "            w = x.ss;",
		  "            v = x.ff;",
		  "            if(vis[v]) continue;",
		  "            if(d[v] > d[u] + w) { ",
		  "                d[v] = d[u] + w;",
		  "                PQ.push({d[v], v});",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "}"
		],
		"description": "Dijkstra"
	  },
   "Custom hash": {
	"prefix": "chash",
	"body": [
	  "struct custom_hash {",
	  "    static uint64_t splitmix64(uint64_t x) {",
	  "        x += 0x9e3779b97f4a7c15;",
	  "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
	  "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
	  "        return x ^ (x >> 31);",
	  "    }",
	  "",
	  "    size_t operator()(uint64_t x) const {",
	  "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
	  "        return splitmix64(x + FIXED_RANDOM);",
	  "    }",
	  "};"
	],
	"description": "Custom hash"
  },
  "Cumulative XOR": {
	"prefix": "cumXor",
	"body": [
	  "int cumulativeXOR(int n)",
	  "{",
	  "  if (n % 4 == 0)",
	  "    return n;",
	  "  if (n % 4 == 1)",
	  "    return 1;",
	  "  if (n % 4 == 2)",
	  "    return n + 1;",
	  "  return 0;",
	  "}"
	],
	"description": "Cumulative XOR"
  },
  "Modulo Functions": {
	"prefix": "modfun",
	"body": [
	  "const int mod = 1e9 + 7;",
	  " ",
	  "int add(int a, int b){",
	  "    int res = (a + b) % mod;",
	  "    if(res < 0)",
	  "        res += mod;",
	  "    return res;",
	  "}",
	  " ",
	  "int mult(int a, int b){",
	  "    int res = (a * 1LL * b) % mod;",
	  "    if(res < 0)",
	  "        res += mod;",
	  "    return res;",
	  "}",
	  " ",
	  "int power(int a, int b){",
	  "    int res = 1;",
	  "    while(b){",
	  "        if((b % 2) == 1)",
	  "            res = mult(res, a);",
	  "        a = mult(a, a);",
	  "        b /= 2;",
	  "    }",
	  "    return res;",
	  "}"
	],
	"description": "Modulo Functions"
  },
  "Sieve of Eratosthenes": {
	"prefix": "sieve",
	"body": [
	  "const int MAX = 1e6+1;",
	  "bool prime[MAX];",
	  "",
	  "void sieve()",
	  "{",
	  "    mem(prime,true);",
	  " ",
	  "    for (int p = 2; p * p <= MAX; p++)",
	  "    {",
	  "        if (prime[p] == true)",
	  "        {",
	  "            for (int i = p * p; i <= MAX; i += p)",
	  "                prime[i] = false;",
	  "        }",
	  "    }",
	  "}"
	],
	"description": "Sieve of Eratosthenes"
  },
  "Prime Factors": {
	"prefix": "primefactors",
	"body": [
	  "vvi f(int(1e5)+1);",
	  "const int MAX = 1e6+1;",
	  "bool prime[MAX];",
	  "",
	  "void sieve()",
	  "{",
	  "    mem(prime,true);",
	  " ",
	  "    for (int p = 2; p * p <= MAX; p++)",
	  "    {",
	  "        if (prime[p] == true)",
	  "        {",
	  "            for (int i = p * p; i <= MAX; i += p)",
	  "                prime[i] = false;",
	  "        }",
	  "    }",
	  "}",
	  "",
	  "void pre(){",
	  "    sieve();",
	  "    FOR(i,2,int(1e5)+1)",
	  "    {",
	  "        if ( prime[i] )",
	  "        {",
	  "            int p = i;",
	  "            while(p<int(1e5)+1)",
	  "            {",
	  "                f[p].pb(i);",
	  "                p+=i;",
	  "            }",
	  "        }",
	  "    }",
	  "}"
	],
	"description": "Prime Factors"
  },
  "Factors": {
	"prefix": "factors",
	"body": [
	  "const int MAX = 1e6+1;",
	  "vvi f(MAX);",
	  "",
	  "void factors(){",
	  "    FOR(i,1,MAX+1)",
	  "    {",
	  "        int  p=i;",
	  "        while(p<MAX)",
	  "        {",
	  "            f[p].pb(i);",
	  "            p+=i;",
	  "        }",
	  "    }",
	  "}"
	],
	"description": "Factors"
  }
}